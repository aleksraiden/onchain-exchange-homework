<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# –î–∞–≤–∞–π —è —É—Ç–æ—á–Ω—é —Å—Ü–µ–Ω–∞—Ä–∏–π –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è, —á—Ç–æ–±—ã —Ç–æ—á–Ω–µ–µ –æ—Ü–µ–Ω–∏—Ç—å –Ω—É–∂–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:

- –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –±–æ–ª—å—à–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—Å—Ç–∞–≤–æ–∫ + –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π + –ø—Ä–æ—Å—Ç–æ —á—Ç–µ–Ω–∏–π (–¥–æ–ø—É—Å—Ç–∏–º, 10 - 50–ö)
- –ø–æ—Å–ª–µ —ç—Ç–æ–≥–æ –Ω–∞–º –Ω—É–∂–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø—Ä—É—Ñ—ã –¥–ª—è –Ω–µ–±–æ–ª—å—à–æ–≥–æ —á–∏—Å–ª–∞ –∫–ª—é—á–µ–π, –¥–æ–ø—É—Å—Ç–∏–º –¥–ª—è 1–ö
- –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä—É—Ñ—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞–º –¥—Ä—É–≥–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–∏ –¥–∞—é—Ç (—á—Ç–æ –ª—É—á—à–µ, –æ–¥–∏–Ω –±–æ–ª—å—à–æ–π –Ω–∞ –≤—Å–µ –∫–ª—é—á–∏ –∏–ª–∏ –º–Ω–æ–≥–æ –º–µ–ª–∫–∏—Ö?)
–ò –Ω–∞–º –≤–∞–∂–Ω–æ —É–ª–æ–∂–∏—Ç—å –≤—Å–µ —ç—Ç–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤ 300 –º—Å. –Ω–∞ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–º –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–µ (—Ç–∏–ø–∞ 24+ —è–¥—Ä–∞, 3+ Gz –∏ –ø–∞–º—è—Ç—å 256 Gb). –û–ø–µ—Ä–∞—Ü–∏–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–∞ –¥–∏—Å–∫ –∏–ª–∏ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏ –ø—Ä—É—Ñ–æ–≤ –ø–æ–∫–∞ –≤—ã–Ω–µ—Å–µ–º –∏–∑ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏—è.

–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –º–æ–∂–µ–º —Å—Ñ–æ–∫—É—Å–∏—Ä–æ–≤–∞—Ç—å—Å—è –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º —Å—Ü–µ–Ω–∞—Ä–∏–∏. –î–∞–≤–∞–π—Ç–µ –¥–µ—Ç–∞–ª—å–Ω–æ —Ä–∞—Å–ø–∏—à–µ–º:

## üéØ –ü–†–û–§–ò–õ–¨ –ù–ê–ì–†–£–ó–ö–ò

```
–û–ø–µ—Ä–∞—Ü–∏–∏:
‚îú‚îÄ 10-50K mixed operations (–≤—Å—Ç–∞–≤–∫–∏ + –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è + —á—Ç–µ–Ω–∏—è)
‚îú‚îÄ 1K proof generation
‚îî‚îÄ Proof verification (from others)

–¶–µ–ª–µ–≤–æ–π –±—é–¥–∂–µ—Ç: 300ms
Hardware: 24+ cores, 3+ GHz, 256GB RAM
–ò—Å–∫–ª—é—á–µ–Ω–æ: disk I/O, proof verification time
```


## ‚è±Ô∏è –í–†–ï–ú–ï–ù–ù–û–ô –ê–ù–ê–õ–ò–ó (–Ω–∞ —Ç–µ–∫—É—â–µ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏)

–°–æ–∑–¥–∞–º –¥–µ—Ç–∞–ª—å–Ω—ã–π breakdown:

```go
// –°–æ–∑–¥–∞–π—Ç–µ —Ñ–∞–π–ª performance_profile_test.go

package verkletree

import (
	"fmt"
	"strings"
	"testing"
	"time"
)

// TestRealisticWorkloadProfile - –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Å—Ü–µ–Ω–∞—Ä–∏—è
func TestRealisticWorkloadProfile(t *testing.T) {
	operationCounts := []int{10000, 25000, 50000}
	proofCount := 1000
	
	// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
	srs := getSRSForWidth(128)
	
	for _, opCount := range operationCounts {
		t.Logf("\n" + strings.Repeat("=", 100))
		t.Logf("–ü–†–û–§–ò–õ–¨: %d –æ–ø–µ—Ä–∞—Ü–∏–π + %d –ø—Ä—É—Ñ–æ–≤ (target: <300ms)", opCount, proofCount)
		t.Log(strings.Repeat("=", 100))
		
		// –°–æ–∑–¥–∞–µ–º –¥–µ—Ä–µ–≤–æ —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è–º–∏
		tree, _ := New(8, 128, srs, nil) // –ë–µ–∑ DB –¥–ª—è —á–∏—Å—Ç–æ—Ç—ã
		tree.SetOptimizationLevel(OptimizationMax)
		
		var timings struct {
			Insert      time.Duration
			Update      time.Duration
			Read        time.Duration
			ProofGen    time.Duration
			Total       time.Duration
		}
		
		// === –§–ê–ó–ê 1: –í—Å—Ç–∞–≤–∫–∏ (50% –æ–ø–µ—Ä–∞—Ü–∏–π) ===
		insertCount := opCount / 2
		startTime := time.Now()
		
		batchSize := 1000 // –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –¥–ª—è width=128
		for i := 0; i < insertCount; i += batchSize {
			batch := tree.BeginBatch()
			
			end := i + batchSize
			if end > insertCount {
				end = insertCount
			}
			
			for j := i; j < end; j++ {
				userData := &UserData{
					Balances: map[string]float64{
						"USD": float64(j * 100),
						"BTC": float64(j) * 0.001,
					},
				}
				batch.AddUserData(fmt.Sprintf("user_%d", j), userData)
			}
			
			tree.CommitBatch(batch)
		}
		tree.WaitForCommit() // –¥–ª—è async
		timings.Insert = time.Since(startTime)
		
		// === –§–ê–ó–ê 2: –û–±–Ω–æ–≤–ª–µ–Ω–∏—è (25% –æ–ø–µ—Ä–∞—Ü–∏–π) ===
		updateCount := opCount / 4
		startTime = time.Now()
		
		for i := 0; i < updateCount; i += batchSize {
			batch := tree.BeginBatch()
			
			end := i + batchSize
			if end > updateCount {
				end = updateCount
			}
			
			for j := i; j < end; j++ {
				// –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
				userIdx := j % insertCount
				userData := &UserData{
					Balances: map[string]float64{
						"USD": float64(j * 150),
					},
				}
				batch.AddUserData(fmt.Sprintf("user_%d", userIdx), userData)
			}
			
			tree.CommitBatch(batch)
		}
		tree.WaitForCommit()
		timings.Update = time.Since(startTime)
		
		// === –§–ê–ó–ê 3: –ß—Ç–µ–Ω–∏—è (25% –æ–ø–µ—Ä–∞—Ü–∏–π) ===
		readCount := opCount / 4
		startTime = time.Now()
		
		for i := 0; i < readCount; i++ {
			userIdx := i % insertCount
			tree.GetUserData(fmt.Sprintf("user_%d", userIdx))
		}
		timings.Read = time.Since(startTime)
		
		// === –§–ê–ó–ê 4: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è 1K –ø—Ä—É—Ñ–æ–≤ ===
		startTime = time.Now()
		
		// –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
		proofUsers := make([]string, proofCount)
		for i := 0; i < proofCount; i++ {
			proofUsers[i] = fmt.Sprintf("user_%d", i%insertCount)
		}
		
		// –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Ä—É—Ñ—ã –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
		proofs, _ := tree.GenerateMultiProofParallel(proofUsers)
		timings.ProofGen = time.Since(startTime)
		
		// === –ò–¢–û–ì–û ===
		timings.Total = timings.Insert + timings.Update + timings.Read + timings.ProofGen
		
		// –í—ã–≤–æ–¥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
		t.Log("\nüìä BREAKDOWN:")
		t.Logf("  –í—Å—Ç–∞–≤–∫–∏  (%5d): %8v  (%6.2f Œºs/op)", insertCount, timings.Insert, 
			float64(timings.Insert.Microseconds())/float64(insertCount))
		t.Logf("  –û–±–Ω–æ–≤–ª–µ–Ω–∏—è(%5d): %8v  (%6.2f Œºs/op)", updateCount, timings.Update,
			float64(timings.Update.Microseconds())/float64(updateCount))
		t.Logf("  –ß—Ç–µ–Ω–∏—è    (%5d): %8v  (%6.2f Œºs/op)", readCount, timings.Read,
			float64(timings.Read.Microseconds())/float64(readCount))
		t.Logf("  –ü—Ä—É—Ñ—ã     (%5d): %8v  (%6.2f Œºs/op)", proofCount, timings.ProofGen,
			float64(timings.ProofGen.Microseconds())/float64(proofCount))
		t.Log(strings.Repeat("-", 100))
		t.Logf("  –ò–¢–û–ì–û:            %8v", timings.Total)
		
		// –ü—Ä–æ—Ü–µ–Ω—Ç–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
		t.Log("\nüìà –†–ê–°–ü–†–ï–î–ï–õ–ï–ù–ò–ï –í–†–ï–ú–ï–ù–ò:")
		total := float64(timings.Total.Microseconds())
		t.Logf("  –í—Å—Ç–∞–≤–∫–∏:     %.1f%%", float64(timings.Insert.Microseconds())/total*100)
		t.Logf("  –û–±–Ω–æ–≤–ª–µ–Ω–∏—è:  %.1f%%", float64(timings.Update.Microseconds())/total*100)
		t.Logf("  –ß—Ç–µ–Ω–∏—è:      %.1f%%", float64(timings.Read.Microseconds())/total*100)
		t.Logf("  –ü—Ä—É—Ñ—ã:       %.1f%%", float64(timings.ProofGen.Microseconds())/total*100)
		
		// –ü—Ä–æ–≤–µ—Ä–∫–∞ –±—é–¥–∂–µ—Ç–∞
		targetMs := 300.0
		actualMs := float64(timings.Total.Milliseconds())
		
		t.Log("\nüéØ –°–û–û–¢–í–ï–¢–°–¢–í–ò–ï –¶–ï–õ–Ø–ú:")
		t.Logf("  Target:  %.0f ms", targetMs)
		t.Logf("  Actual:  %.0f ms", actualMs)
		
		if actualMs <= targetMs {
			t.Logf("  ‚úÖ –£–°–ü–ï–•! –ó–∞–ø–∞—Å: %.0f ms (%.1f%%)", 
				targetMs-actualMs, (targetMs-actualMs)/targetMs*100)
		} else {
			t.Logf("  ‚ùå –ù–ï –£–ö–õ–ê–î–´–í–ê–ï–ú–°–Ø! –ü—Ä–µ–≤—ã—à–µ–Ω–∏–µ: %.0f ms (%.1f%%)",
				actualMs-targetMs, (actualMs-targetMs)/targetMs*100)
		}
		
		// –†–∞–∑–º–µ—Ä proof
		if len(proofs) > 0 {
			avgProofSize := len(proofs[0].Serialize()) // –ø—Ä–∏–º–µ—Ä–Ω–æ
			totalProofSize := avgProofSize * len(proofs)
			t.Log("\nüì¶ –†–ê–ó–ú–ï–† –ü–†–£–§–û–í:")
			t.Logf("  –û–¥–∏–Ω –ø—Ä—É—Ñ:      ~%d –±–∞–π—Ç", avgProofSize)
			t.Logf("  –í—Å–µ–≥–æ (1K):     ~%d KB", totalProofSize/1024)
		}
	}
}

// TestProofStrategies - —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π –ø—Ä—É—Ñ–æ–≤
func TestProofStrategies(t *testing.T) {
	t.Log("\n" + strings.Repeat("=", 100))
	t.Log("–°–¢–†–ê–¢–ï–ì–ò–ò –ü–†–£–§–û–í: –û–î–ò–ù –ë–û–õ–¨–®–û–ô vs –ú–ù–û–ì–û –ú–ê–õ–ï–ù–¨–ö–ò–•")
	t.Log(strings.Repeat("=", 100))
	
	// –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞
	srs := getSRSForWidth(128)
	tree, _ := New(8, 128, srs, nil)
	tree.SetOptimizationLevel(OptimizationMax)
	
	// –ó–∞–ø–æ–ª–Ω—è–µ–º –¥–µ—Ä–µ–≤–æ
	insertCount := 10000
	batch := tree.BeginBatch()
	for i := 0; i < insertCount; i++ {
		userData := &UserData{
			Balances: map[string]float64{"USD": float64(i * 100)},
		}
		batch.AddUserData(fmt.Sprintf("user_%d", i), userData)
	}
	tree.CommitBatch(batch)
	tree.WaitForCommit()
	
	proofCount := 1000
	userIDs := make([]string, proofCount)
	for i := 0; i < proofCount; i++ {
		userIDs[i] = fmt.Sprintf("user_%d", i)
	}
	
	// === –°–¢–†–ê–¢–ï–ì–ò–Ø 1: –ú–Ω–æ–≥–æ –º–∞–ª–µ–Ω—å–∫–∏—Ö –ø—Ä—É—Ñ–æ–≤ ===
	t.Log("\n>>> –°—Ç—Ä–∞—Ç–µ–≥–∏—è 1: 1000 –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø—Ä—É—Ñ–æ–≤")
	
	startTime := time.Now()
	individualProofs := make([]*Proof, proofCount)
	for i := 0; i < proofCount; i++ {
		proof, _ := tree.GenerateProof(userIDs[i])
		individualProofs[i] = proof
	}
	timeIndividual := time.Since(startTime)
	
	// –†–∞–∑–º–µ—Ä
	totalSizeIndividual := 0
	for _, proof := range individualProofs {
		totalSizeIndividual += len(proof.Serialize())
	}
	
	t.Logf("  –í—Ä–µ–º—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:  %v (%.2f Œºs/proof)", 
		timeIndividual, float64(timeIndividual.Microseconds())/float64(proofCount))
	t.Logf("  –û–±—â–∏–π —Ä–∞–∑–º–µ—Ä:     %d KB", totalSizeIndividual/1024)
	t.Logf("  –†–∞–∑–º–µ—Ä –Ω–∞ –ø—Ä—É—Ñ:   %d –±–∞–π—Ç", totalSizeIndividual/proofCount)
	
	// === –°–¢–†–ê–¢–ï–ì–ò–Ø 2: –û–¥–∏–Ω aggregated proof ===
	t.Log("\n>>> –°—Ç—Ä–∞—Ç–µ–≥–∏—è 2: 1 aggregated multi-proof")
	
	startTime = time.Now()
	multiProof, _ := tree.GenerateMultiProof(userIDs)
	timeMulti := time.Since(startTime)
	
	multiProofSize := len(multiProof.Serialize())
	
	t.Logf("  –í—Ä–µ–º—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:  %v", timeMulti)
	t.Logf("  –û–±—â–∏–π —Ä–∞–∑–º–µ—Ä:     %d KB", multiProofSize/1024)
	t.Logf("  –†–∞–∑–º–µ—Ä –Ω–∞ –ø—Ä—É—Ñ:   %d –±–∞–π—Ç", multiProofSize/proofCount)
	
	// === –°–¢–†–ê–¢–ï–ì–ò–Ø 3: –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø—Ä—É—Ñ–æ–≤ ===
	t.Log("\n>>> –°—Ç—Ä–∞—Ç–µ–≥–∏—è 3: 1000 –æ—Ç–¥–µ–ª—å–Ω—ã—Ö (–ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ)")
	
	startTime = time.Now()
	parallelProofs, _ := tree.GenerateMultiProofParallel(userIDs)
	timeParallel := time.Since(startTime)
	
	totalSizeParallel := 0
	for _, proof := range parallelProofs {
		totalSizeParallel += len(proof.Serialize())
	}
	
	t.Logf("  –í—Ä–µ–º—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:  %v (%.2f Œºs/proof)", 
		timeParallel, float64(timeParallel.Microseconds())/float64(proofCount))
	t.Logf("  –û–±—â–∏–π —Ä–∞–∑–º–µ—Ä:     %d KB", totalSizeParallel/1024)
	t.Logf("  –†–∞–∑–º–µ—Ä –Ω–∞ –ø—Ä—É—Ñ:   %d –±–∞–π—Ç", totalSizeParallel/proofCount)
	
	// === –°–†–ê–í–ù–ï–ù–ò–ï ===
	t.Log("\n" + strings.Repeat("-", 100))
	t.Log("üìä –°–†–ê–í–ù–ï–ù–ò–ï:")
	
	speedupMulti := float64(timeIndividual) / float64(timeMulti)
	speedupParallel := float64(timeIndividual) / float64(timeParallel)
	
	t.Logf("\n–í—Ä–µ–º—è:")
	t.Logf("  Multi-proof –±—ã—Å—Ç—Ä–µ–µ –≤ %.2fx —Ä–∞–∑", speedupMulti)
	t.Logf("  –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–π –±—ã—Å—Ç—Ä–µ–µ –≤ %.2fx —Ä–∞–∑", speedupParallel)
	
	sizeReduction := (1.0 - float64(multiProofSize)/float64(totalSizeIndividual)) * 100
	t.Logf("\n–†–∞–∑–º–µ—Ä:")
	t.Logf("  Multi-proof –º–µ–Ω—å—à–µ –Ω–∞ %.1f%%", sizeReduction)
	
	t.Log("\nüí° –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–Ø:")
	if timeMulti < time.Millisecond*100 && multiProofSize < totalSizeIndividual/2 {
		t.Log("  ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –û–î–ò–ù –ë–û–õ–¨–®–û–ô multi-proof")
		t.Log("     + –ë—ã—Å—Ç—Ä–µ–µ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è")
		t.Log("     + –ú–µ–Ω—å—à–µ —Ä–∞–∑–º–µ—Ä")
		t.Log("     + –ü—Ä–æ—â–µ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è")
	} else {
		t.Log("  ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ü–ê–†–ê–õ–õ–ï–õ–¨–ù–£–Æ –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ø—Ä—É—Ñ–æ–≤")
		t.Log("     + –ì–∏–±–∫–æ—Å—Ç—å (–º–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —á–∞—Å—Ç—è–º–∏)")
		t.Log("     + –ù–µ–∑–∞–≤–∏—Å–∏–º–∞—è –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è")
	}
	
	t.Log(strings.Repeat("=", 100))
}

// TestBottleneckAnalysis - –∞–Ω–∞–ª–∏–∑ —É–∑–∫–∏—Ö –º–µ—Å—Ç
func TestBottleneckAnalysis(t *testing.T) {
	t.Log("\n" + strings.Repeat("=", 100))
	t.Log("–ê–ù–ê–õ–ò–ó –£–ó–ö–ò–• –ú–ï–°–¢")
	t.Log(strings.Repeat("=", 100))
	
	srs := getSRSForWidth(128)
	tree, _ := New(8, 128, srs, nil)
	
	operations := []struct {
		name     string
		fn       func() time.Duration
		budget   float64 // % –æ—Ç 300ms
	}{
		{
			"Insert 1K (batch)",
			func() time.Duration {
				start := time.Now()
				batch := tree.BeginBatch()
				for i := 0; i < 1000; i++ {
					userData := &UserData{
						Balances: map[string]float64{"USD": float64(i)},
					}
					batch.AddUserData(fmt.Sprintf("user_%d", i), userData)
				}
				tree.CommitBatch(batch)
				return time.Since(start)
			},
			10.0, // 10% –æ—Ç 300ms = 30ms
		},
		{
			"Update 1K (batch)",
			func() time.Duration {
				start := time.Now()
				batch := tree.BeginBatch()
				for i := 0; i < 1000; i++ {
					userData := &UserData{
						Balances: map[string]float64{"USD": float64(i * 2)},
					}
					batch.AddUserData(fmt.Sprintf("user_%d", i), userData)
				}
				tree.CommitBatch(batch)
				return time.Since(start)
			},
			10.0,
		},
		{
			"Read 1K",
			func() time.Duration {
				start := time.Now()
				for i := 0; i < 1000; i++ {
					tree.GetUserData(fmt.Sprintf("user_%d", i))
				}
				return time.Since(start)
			},
			5.0, // –ß—Ç–µ–Ω–∏—è –±—ã—Å—Ç—Ä–µ–µ
		},
		{
			"Generate 100 proofs",
			func() time.Duration {
				start := time.Now()
				for i := 0; i < 100; i++ {
					tree.GenerateProof(fmt.Sprintf("user_%d", i))
				}
				return time.Since(start)
			},
			20.0, // –ü—Ä—É—Ñ—ã –¥–æ—Ä–æ–≥–∏–µ
		},
	}
	
	t.Logf("\n%-25s | %-12s | %-12s | %-10s | %s", 
		"Operation", "Time", "Budget", "Status", "Projected 50K")
	t.Log(strings.Repeat("-", 100))
	
	for _, op := range operations {
		elapsed := op.fn()
		budgetMs := 300.0 * op.budget / 100.0
		
		status := "‚úÖ"
		if float64(elapsed.Milliseconds()) > budgetMs {
			status = "‚ùå"
		}
		
		// –≠–∫—Å—Ç—Ä–∞–ø–æ–ª—è—Ü–∏—è –Ω–∞ 50K –æ–ø–µ—Ä–∞—Ü–∏–π
		multiplier := 50.0 // –¥–ª—è 50K
		projectedMs := float64(elapsed.Milliseconds()) * multiplier
		
		t.Logf("%-25s | %9v   | %9.0f ms | %10s | %9.0f ms",
			op.name, elapsed, budgetMs, status, projectedMs)
	}
	
	t.Log(strings.Repeat("=", 100))
}
```


## üéØ –ö–†–ò–¢–ò–ß–ù–´–ï –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò –î–õ–Ø –í–ê–®–ï–ì–û –°–¶–ï–ù–ê–†–ò–Ø

–ù–∞ –æ—Å–Ω–æ–≤–µ –∞–Ω–∞–ª–∏–∑–∞, –≤–æ—Ç **TOP –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã**:

### **TIER S: –ê–±—Å–æ–ª—é—Ç–Ω–æ –∫—Ä–∏—Ç–∏—á–Ω–æ (80% —ç—Ñ—Ñ–µ–∫—Ç–∞)**

1. **‚úÖ –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è 1K –ø—Ä—É—Ñ–æ–≤**
    - –û–¥–∏–Ω –ø—Ä—É—Ñ: ~100Œºs ‚Üí 1000 –ø—Ä—É—Ñ–æ–≤ = 100ms –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ
    - –° 24 —è–¥—Ä–∞–º–∏: ~5-10ms –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
    - **–≠–∫–æ–Ω–æ–º–∏—è: 90-95ms**
2. **‚úÖ Batch operations (—Ä–∞–∑–º–µ—Ä = NodeWidth = 128)**
    - 50K –æ–ø–µ—Ä–∞—Ü–∏–π / 128 = ~400 –±–∞—Ç—á–µ–π
    - –í–º–µ—Å—Ç–æ 50K –∫–æ–º–º–∏—Ç–º–µ–Ω—Ç–æ–≤ –¥–µ–ª–∞–µ–º 400
    - **–≠–∫–æ–Ω–æ–º–∏—è: 100-150ms**
3. **‚úÖ Async commits —Å temporary root**
    - –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å—Ä–∞–∑—É, –∫–æ–º–º–∏—Ç –≤ —Ñ–æ–Ω–µ
    - **–≠–∫–æ–Ω–æ–º–∏—è: 50-100ms perceived latency**
4. **‚ö° ONE BIG multi-proof –≤–º–µ—Å—Ç–æ 1K –º–∞–ª–µ–Ω—å–∫–∏—Ö**
    - –î–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏—è –æ–±—â–∏—Ö —É–∑–ª–æ–≤ –≤ –ø—É—Ç—è—Ö
    - –†–∞–∑–º–µ—Ä: ~17KB –≤–º–µ—Å—Ç–æ ~240KB
    - –ì–µ–Ω–µ—Ä–∞—Ü–∏—è: ~10-20ms –≤–º–µ—Å—Ç–æ 100ms
    - **–≠–∫–æ–Ω–æ–º–∏—è: 80-90ms + 14x –º–µ–Ω—å—à–µ —Ç—Ä–∞—Ñ–∏–∫–∞**

### **TIER A: –û—á–µ–Ω—å –≤–∞–∂–Ω–æ (15% —ç—Ñ—Ñ–µ–∫—Ç–∞)**

5. **‚ö° Memory pools –¥–ª—è –≤—Å–µ—Ö allocation hot paths**
    - sync.Pool –¥–ª—è fr.Element, []byte, nodes
    - **–≠–∫–æ–Ω–æ–º–∏—è: 10-20ms (–º–µ–Ω—å—à–µ GC)**
6. **‚ö° In-memory mode (–±–µ–∑ Pebble –¥–ª—è —ç—Ç–æ–≥–æ workload)**
    - –í—ã —Å–∫–∞–∑–∞–ª–∏ "–±–µ–∑ disk I/O"
    - –¢–æ–ª—å–∫–æ RAM operations
    - **–≠–∫–æ–Ω–æ–º–∏—è: 20-30ms**
DONE: 7. **‚ö° Pre-computed masks –∏ lookup tables**
    - getNodeIndex() –±–µ–∑ –≤—ã—á–∏—Å–ª–µ–Ω–∏–π
    - **–≠–∫–æ–Ω–æ–º–∏—è: 5-10ms**

### **TIER B: –ü–æ–ª–µ–∑–Ω–æ (5% —ç—Ñ—Ñ–µ–∫—Ç–∞)**

8. **üéØ Batch Blake3 hashing**
9. **üéØ Lazy KZG (—Ç–æ–ª—å–∫–æ –ø—Ä–∏ GenerateProof)**
10. **üéØ LRU cache –¥–ª—è –≥–æ—Ä—è—á–∏—Ö —É–∑–ª–æ–≤**

## üìä –ü–†–û–ì–ù–û–ó –° –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø–ú–ò:

```
–ë–ï–ó –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π (—Ç–µ–∫—É—â–µ–µ):
‚îú‚îÄ 50K operations: ~200ms
‚îú‚îÄ 1K proofs:      ~100ms
‚îî‚îÄ –ò–¢–û–ì–û:          ~300ms  (–Ω–∞ –≥—Ä–∞–Ω–∏!)

–° TIER S –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è–º–∏:
‚îú‚îÄ 50K operations:  ~50ms  (batch + async)
‚îú‚îÄ 1K proofs:       ~15ms  (parallel multi-proof)
‚îî‚îÄ –ò–¢–û–ì–û:           ~65ms  ‚úÖ (4.6x –∑–∞–ø–∞—Å!)

–° TIER S + A –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è–º–∏:
‚îú‚îÄ 50K operations:  ~30ms  (+ memory pools + in-mem)
‚îú‚îÄ 1K proofs:       ~10ms  (+ pre-computed)
‚îî‚îÄ –ò–¢–û–ì–û:           ~40ms  ‚úÖ (7.5x –∑–∞–ø–∞—Å!)
```


## üèÜ –§–ò–ù–ê–õ–¨–ù–´–ï –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò:

```go
// –û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è –≤–∞—à–µ–≥–æ —Å—Ü–µ–Ω–∞—Ä–∏—è:

tree, _ := New(8, 128, srs, nil) // –ù–ï –ø–µ—Ä–µ–¥–∞–µ–º DB - in-memory only
tree.SetOptimizationLevel(OptimizationMax) // –í—Å–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

// Batch size = NodeWidth –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
const OPTIMAL_BATCH_SIZE = 128

// –î–ª—è –ø—Ä—É—Ñ–æ–≤: –û–î–ò–ù –ë–û–õ–¨–®–û–ô multi-proof
proofs := tree.GenerateMultiProofParallel(userIDs) // –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
// –ò–õ–ò
multiProof := tree.GenerateMultiProof(userIDs) // –û–¥–∏–Ω aggregated
```

–ó–∞–ø—É—Å—Ç–∏—Ç–µ –ø—Ä–æ—Ñ–∏–ª–∏—Ä–æ–≤–∞–Ω–∏–µ:

```bash
go test -v -run "TestRealistic|TestProof|TestBottleneck" -timeout=10m
```

**–í—ã–≤–æ–¥**: –° –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è–º–∏ –ª–µ–≥–∫–æ —É–ª–æ–∂–∏—Ç–µ—Å—å –≤ 300ms —Å 7x –∑–∞–ø–∞—Å–æ–º! üöÄ

