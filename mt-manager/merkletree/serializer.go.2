package merkletree

import "fmt"

// Serializable интерфейс для сериализации/десериализации элементов
type Serializable interface {
	Hashable
	// Serialize сериализует элемент в байты
	Serialize() []byte
	// Deserialize восстанавливает элемент из байтов
	Deserialize(data []byte) error
}

// TypeRegistry регистр типов для десериализации
type TypeRegistry[T Hashable] struct {
	factory func() T // Фабрика для создания новых экземпляров
}

// NewTypeRegistry создает новый регистр типов
func NewTypeRegistry[T Hashable](factory func() T) *TypeRegistry[T] {
	return &TypeRegistry[T]{
		factory: factory,
	}
}

// CreateInstance создает новый экземпляр типа T
func (tr *TypeRegistry[T]) CreateInstance() T {
	return tr.factory()
}

// SerializeWithType сериализует элемент с проверкой типа
func SerializeWithType[T Hashable](item T) ([]byte, error) {
	if serializable, ok := any(item).(Serializable); ok {
		return serializable.Serialize(), nil
	}
	return nil, fmt.Errorf("type does not implement Serializable interface")
}

// DeserializeWithType десериализует элемент
func DeserializeWithType[T Hashable](data []byte, factory func() T) (T, error) {
	item := factory()
	
	if serializable, ok := any(item).(Serializable); ok {
		if err := serializable.Deserialize(data); err != nil {
			var zero T
			return zero, err
		}
		return item, nil
	}
	
	var zero T
	return zero, fmt.Errorf("type does not implement Serializable interface")
}
